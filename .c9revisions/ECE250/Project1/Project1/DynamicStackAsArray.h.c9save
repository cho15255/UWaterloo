{"ts":1359840336367,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#ifndef DYNAMIC_STACK_AS_ARRAY_H\r\n#define DYNAMIC_STACK_AS_ARRAY_H\r\n\r\n/*****************************************\r\n * UW User ID:  jh9cho \r\n * Submitted for ECE 250\r\n * Semester of Submission:  (Winter) 2013\r\n *\r\n * By submitting this file, I affirm that\r\n * I am the author of all modifications to\r\n * the provided code.\r\n *****************************************/\r\n \r\n #include <iostream>\r\nusing namespace std;\r\n\r\n#include \"Exception.h\"\r\n#include \"Array.h\"\r\n\r\ntemplate <typename T>\r\nclass DynamicStackAsArray {\r\n    private:\r\n\t\t\r\n\t\tArray<T> *stack ; \r\n\t\tint ihead, count, initial_size, array_size;\r\n\r\n\tpublic:\r\n\t\tDynamicStackAsArray( int = 10 );\r\n\t\t~DynamicStackAsArray();\r\n\r\n\t\tT top() const;\r\n\t\tint size() const;\r\n\t\tbool empty() const;\r\n\t\tint capacity() const;\r\n\r\n\t\tvoid push( T const & );\r\n\t\tT pop();\r\n\t\tvoid clear();\r\n\t\tvoid print();\r\n\t\r\n        void stackResize(int ) ;\r\n};\r\n\r\ntemplate <typename T>\r\nDynamicStackAsArray<T>::DynamicStackAsArray( int n ):\r\ncount( 0 ),\r\ninitial_size( n ),\r\narray_size( n ) {            \r\n      \r\n\t   stack = new Array<T>(array_size);\r\n\t   ihead = -1;\r\n}\r\n\r\ntemplate <typename T>\r\nDynamicStackAsArray<T>::~DynamicStackAsArray() {\r\n\tdelete stack;\r\n}\r\n\r\ntemplate <typename  T>\r\nT DynamicStackAsArray<T>::top() const {\r\n    \r\n    if (count > 0) {\r\n       return stack->get(ihead);\r\n    } else {\r\n       throw underflow();\r\n    }\r\n}\r\n\r\ntemplate <typename T>\r\nint DynamicStackAsArray<T>::size() const {\r\n\treturn count;\r\n}\r\n\r\ntemplate <typename T>\r\nbool DynamicStackAsArray<T>::empty() const {\r\n\tif (array_size == 0) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\ntemplate <typename T>\r\nint DynamicStackAsArray<T>::capacity() const {\r\n\treturn array_size;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid DynamicStackAsArray<T>::push( T const &obj ) {\r\n    if (count >= array_size) {\r\n        array_size *= 2;\r\n        stack->resize(array_size);\r\n    }\r\n    count ++;\r\n    ihead ++;\r\n\r\n\tstack->set(ihead,obj);\r\n}\r\n\r\ntemplate <typename T>\r\nT DynamicStackAsArray<T>::pop() {\r\n    if (count <= 0) {\r\n        throw underflow();\r\n    }\r\n    \r\n\tT temp = top();\r\n\r\n    if (array_size > initial_size && count <= array_size/4) {\r\n        array_size /= 2;\r\n        stack->resize(array_size);\r\n\t}\r\n\r\n\tstack->set(ihead,0);\r\n\tihead--;\r\n\tcount--;\r\n     \r\n    return temp;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid DynamicStackAsArray<T>::clear() {\r\n    Array<T> *newStack = new Array<T> (initial_size);\r\n    delete [] stack;\r\n    stack = newStack;\r\n}\r\n\r\n#endif"]],"start1":0,"start2":0,"length1":0,"length2":2479}]],"length":2479}
{"contributors":[],"silentsave":false,"ts":1359840339168,"patch":[[{"diffs":[[0,"{\r\n\tif ("],[-1,"array_size"],[1,"count"],[0," == 0) {"]],"start1":1522,"start2":1522,"length1":26,"length2":21}]],"length":2474,"saved":false}
{"contributors":[],"silentsave":false,"ts":1359843057843,"patch":[[{"diffs":[[0,"ad = -1;"],[1," //index of head is setted to -1 since this array is currently empty"],[0,"\r\n}\r\n\r\nt"]],"start1":1079,"start2":1079,"length1":16,"length2":84},{"diffs":[[0,"elete stack;"],[1," //deleting stack array"],[0,"\r\n}\r\n\r\ntempl"]],"start1":1237,"start2":1237,"length1":24,"length2":47}]],"length":2565,"saved":false}
{"ts":1359843117012,"patch":[[{"diffs":[[0,"(ihead);"],[1," //returning top(or head) "],[0,"\r\n    } "]],"start1":1396,"start2":1396,"length1":16,"length2":42},{"diffs":[[0,"onst {\r\n"],[1,"    //return true when the array is empty (every elements are 0)\r\n"],[0,"\tif (cou"]],"start1":1634,"start2":1634,"length1":16,"length2":82}]],"length":2657,"saved":false}
{"ts":1359843187159,"patch":[[{"diffs":[[0,"t &obj ) {\r\n"],[1,"    //when count is greater or equal to array_size, array_size is doubled\r\n"],[0,"    if (coun"]],"start1":1960,"start2":1960,"length1":24,"length2":99}]],"length":2732,"saved":false}
{"ts":1359843202702,"patch":[[{"diffs":[[0,"e);\r\n    }\r\n"],[1,"    //increment count and ihead for indexing\r\n"],[0,"    count ++"]],"start1":2136,"start2":2136,"length1":24,"length2":70}]],"length":2778,"saved":false}
{"ts":1359843223967,"patch":[[{"diffs":[[0,"head ++;\r\n\r\n"],[1,"    //\r\n"],[0,"\tstack->set("]],"start1":2214,"start2":2214,"length1":24,"length2":32}]],"length":2786,"saved":false}
{"ts":1359843239427,"patch":[[{"diffs":[[0,"\r\n    //"],[1,"user's input (obj) is stored in the head"],[0,"\r\n\tstack"]],"start1":2224,"start2":2224,"length1":16,"length2":56}]],"length":2826,"saved":false}
{"ts":1359843242556,"patch":[[{"diffs":[[0," stored "],[-1,"in"],[1,"to"],[0," the hea"]],"start1":2253,"start2":2253,"length1":18,"length2":18}]],"length":2826,"saved":false}
{"ts":1359843307641,"patch":[[{"diffs":[[0,"(count <"],[-1,"="],[0," 0) {\r\n "]],"start1":2369,"start2":2369,"length1":17,"length2":16}]],"length":2825,"saved":false}
{"ts":1359843313127,"patch":[[{"diffs":[[0,"(count <"],[1,"="],[0," 0) {\r\n "]],"start1":2369,"start2":2369,"length1":16,"length2":17}]],"length":2826,"saved":false}
{"ts":1359843360296,"patch":[[{"diffs":[[0,"= top();\r\n\r\n"],[1,"    //if count is less than array_size/4, resize the array_size to half\r\n    \r\n"],[0,"    if (arra"]],"start1":2434,"start2":2434,"length1":24,"length2":103}]],"length":2905,"saved":false}
{"ts":1359843362077,"patch":[[{"diffs":[[0,"o half\r\n"],[-1,"    \r\n"],[0,"    if ("]],"start1":2511,"start2":2511,"length1":22,"length2":16}]],"length":2899,"saved":false}
{"ts":1359843370717,"patch":[[{"diffs":[[0,");\r\n\t}\r\n"],[1,"    \r\n    "],[0,"\r\n\tstack"]],"start1":2640,"start2":2640,"length1":16,"length2":26}]],"length":2909,"saved":false}
{"ts":1359843372216,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[-1,"    \r\n"],[0,"\tstack->"]],"start1":2646,"start2":2646,"length1":22,"length2":16}]],"length":2903,"saved":false}
{"ts":1359843405851,"patch":[[{"diffs":[[0,"\t}\r\n"],[-1,"    \r\n\tstack->set(ihead,0);\r\n\tihead--;\r\n\tcount--;\r\n"],[0,"    "]],"start1":2644,"start2":2644,"length1":59,"length2":8}]],"length":2852,"saved":false}
{"ts":1359843426965,"patch":[[{"diffs":[[0,"top();\r\n"],[1,"    \r\n    \r\n    "],[0,"\r\n    //"]],"start1":2436,"start2":2436,"length1":16,"length2":32}]],"length":2868,"saved":false}
{"ts":1359843434614,"patch":[[{"diffs":[[0,"\r\n    \r\n    "],[1,"stack->set(ihead,0);\r\n    ihead--;\r\n\tcount--;"],[0,"\r\n    \r\n    "]],"start1":2442,"start2":2442,"length1":24,"length2":69}]],"length":2913,"saved":false}
{"ts":1359843597598,"patch":[[{"diffs":[[0,"top();\r\n    "],[1,"//"],[0,"\r\n    stack-"]],"start1":2436,"start2":2436,"length1":24,"length2":26}]],"length":2915,"saved":false}
{"ts":1359843614350,"patch":[[{"diffs":[[0,"\r\n    //"],[1,"set the value 0 to head"],[0,"\r\n    st"]],"start1":2442,"start2":2442,"length1":16,"length2":39}]],"length":2938,"saved":false}
{"ts":1359843766668,"patch":[[{"diffs":[[0,"set "],[-1,"the value 0 to head"],[1,"set delete head by initializing it to 0 and decrementing counters"],[0,"\r\n  "]],"start1":2450,"start2":2450,"length1":27,"length2":73}]],"length":2984,"saved":false}
{"ts":1359844221173,"patch":[[{"diffs":[[0,"lete"],[-1," []"],[0," sta"]],"start1":2934,"start2":2934,"length1":11,"length2":8}]],"length":2981,"saved":false}
{"ts":1359844257956,"patch":[[{"diffs":[[0,":clear() {\r\n"],[1,"    //declares new empty arrya with equal initial_size and change the pointer\r\n    //to the oritinal array to new array\r\n"],[0,"    Array<T>"]],"start1":2861,"start2":2861,"length1":24,"length2":145}]],"length":3102,"saved":false}
