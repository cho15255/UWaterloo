{"ts":1359844506286,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*************************************************\r\n * DynamicStackAsArrayTester\r\n * A class for testing dynamic stack-as-arrays.\r\n *\r\n * Author:  Douglas Wilhelm Harder\r\n * Copyright (c) 2006 by Douglas Wilhelm Harder.  All rights reserved.\r\n *\r\n * DO NOT EDIT THIS FILE\r\n *************************************************/\r\n\r\n#ifndef DYNAMIC_STACK_AS_ARRAY_TESTER_H\r\n#define DYNAMIC_STACK_AS_ARRAY_TESTER_H\r\n\r\n#include \"Exception.h\"\r\n#include \"Tester.h\"\r\n#include \"DynamicStackAsArray.h\"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n\r\nclass DynamicStackAsArrayDoubleTester:public Tester<DynamicStackAsArray<double> > {\r\n    public:\r\n\t\tDynamicStackAsArrayDoubleTester( DynamicStackAsArray<double> *obj = 0 ):Tester<DynamicStackAsArray<double> >( obj ) {\r\n\t\t\t// empty\r\n\t\t}\r\n\t\t\r\n\t\tvirtual void process();\r\n};\r\n\r\n/****************************************************\r\n * void process()\r\n *\r\n * Process the current command.  For dynamic stack-as-arrays, these include:\r\n *\r\n *  Accessors\r\n *\r\n *   size n          size            the size equals n\r\n *   capacity n      capacity        the capcity equals n\r\n *   empty b         empty           the result is the boolean value b\r\n *   top n           top            n is the top element in the stack\r\n *   top!            top            the underflow exception is thrown\r\n *\r\n *  Mutators\r\n *\r\n *   push n          push    the element can be push (always succeeds)\r\n *   pop n           pop    the top can be pop\r\n *   pop!            pop    the underflow exception is thrown\r\n *\r\n *   details                         details about memory allocation\r\n ****************************************************/\r\n\r\nvoid DynamicStackAsArrayDoubleTester::process() {\r\n\tif ( command == \"size\" ) {\r\n\t\t// check if the size equals the next integer read\r\n\r\n\t\tint expected_size;\r\n\r\n\t\tcin >> expected_size;\r\n\r\n\t\tint actual_size = object->size();\r\n\r\n\t\tif ( actual_size == expected_size ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} else {\r\n\t\t\tcout << \"Failure in size(): expecting the value '\" << expected_size << \"' but got '\" << actual_size << \"'\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"capacity\" ) {\r\n\t\t// check if the capacity equals the next integer read\r\n\r\n\t\tint expected_capacity;\r\n\r\n\t\tcin >> expected_capacity;\r\n\r\n\t\tint actual_capacity = object->capacity();\r\n\r\n\t\tif ( actual_capacity == expected_capacity ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} else {\r\n\t\t\tcout << \"Failure in capacity(): expecting the value '\" << expected_capacity << \"' but got '\" << actual_capacity << \"'\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"empty\" ) {\r\n\t\t// check if the empty status equals the next boolean read\r\n\r\n\t\tbool expected_empty;\r\n\r\n\t\tcin >> expected_empty;\r\n\r\n\t\tbool actual_empty = object->empty();\r\n\r\n\t\tif ( actual_empty == expected_empty ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} else {\r\n\t\t\tcout << \"Failure in empty(): expecting the value '\" << expected_empty << \"' but got '\" << actual_empty << \"'\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"top\" ) {\r\n\t\t// checks if the top integer in the stack equals the next integer read\r\n\r\n\t\tdouble expected_top;\r\n\r\n\t\tcin >> expected_top;\r\n\r\n\t\tdouble actual_top = object->top();\r\n\r\n\t\tif ( actual_top == expected_top ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} else {\r\n\t\t\tcout << \"Failure in top(): expecting the value '\" << expected_top << \"' but got '\" << actual_top << \"'\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"top!\" ) {\r\n\t\t// top of an empty stack - catch an exception\r\n\r\n\t\tdouble actual_top;\r\n\r\n\t\ttry {\r\n\t\t\tactual_top = object->top();\r\n\t\t\tcout << \"Failure in top(): expecting to catch an exception but got '\" << actual_top << \"'\" << endl;\r\n\t\t} catch( underflow ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} catch (...) {\r\n\t\t\tcout << \"Failure in top(): expecting an underflow exception but caught a different exception\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"push\" ) {\r\n\t\t// push the next integer read to the front of the stack\r\n\r\n\t\tdouble n;\r\n\r\n\t\tcin >> n;\r\n\r\n\t\tobject->push( n );\r\n\t\tcout << \"Okay\" << endl;\r\n\t} else if ( command == \"pop\" ) {\r\n\t\t// pop the top integer from the stack\r\n\r\n\t\tdouble expected_popped_element;\r\n\r\n\t\tcin >> expected_popped_element;\r\n\r\n\t\tdouble actual_popped_element = object->pop();\r\n\r\n\t\tif ( actual_popped_element == expected_popped_element ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} else {\r\n\t\t\tcout << \"Failure in pop(): expecting the value '\" << expected_popped_element << \"' but got '\" << actual_popped_element << \"'\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"pop!\" ) {\r\n\t\t// pop from an empty stack - catch an exception\r\n\r\n\t\tdouble actual_popped_element;\r\n\r\n\t\ttry {\r\n\t\t\tactual_popped_element = object->pop();\r\n\t\t\tcout << \"Failure in pop(): expecting to catch an exception but got '\" << actual_popped_element << \"'\" << endl;\r\n\t\t} catch( underflow ) {\r\n\t\t\tcout << \"Okay\" << endl;\r\n\t\t} catch (...) {\r\n\t\t\tcout << \"Failure in pop(): expecting an underflow exception but caught a different exception\" << endl;\r\n\t\t}\r\n\t} else if ( command == \"clear\" ) {\r\n\t\tobject->clear();\r\n\r\n\t\tcout << \"Okay\" << endl;\r\n\t} else {\r\n\t\tcout << command << \": Command not found.\" << endl;\r\n\t}\r\n}\r\n#endif"]],"start1":0,"start2":0,"length1":0,"length2":5039}]],"length":5039}
