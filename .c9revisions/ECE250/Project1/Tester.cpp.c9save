{"ts":1359644127073,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1359644262218,"patch":[[{"diffs":[[1,"#include <iostream>\n\nusing namespace std;\n\n#include \"Exception.h\"\n#include \"Array.h\"\n#include \"DynamicStackAsArray.h\""]],"start1":0,"start2":0,"length1":0,"length2":117}]],"length":117,"saved":false}
{"ts":1359644263699,"patch":[[{"diffs":[[0,"cStackAsArray.h\""],[1,"\n\n"]],"start1":101,"start2":101,"length1":16,"length2":18}]],"length":119,"saved":false}
{"contributors":[],"silentsave":false,"ts":1359676832751,"patch":[[{"diffs":[[-1,"#include <iostream>\n\nusing namespace std;\n\n#include \"Exception.h\"\n#include \"Array.h\"\n#include \"DynamicStackAsArray.h\"\n\n"],[1,"/*************************************************\r\n * Tester<ClassName>\r\n * The top-level testing class.  Each derived\r\n * class inherits the routines:\r\n *\r\n *    int run()\r\n *\r\n * For a derived class to function, it must\r\n * override the void process() member function.\r\n * The process function should read in a line from\r\n * the input file and tests the routine based on\r\n * those instructions.\r\n *\r\n * The member variables are:\r\n *\r\n *   ClassName *object   A pointer to the object\r\n *                       being tested.\r\n *\r\n *   string command      The string read in from\r\n *                       the input file indicating\r\n *                       the next command to be\r\n *                       tested.\r\n *\r\n *   int count           The number of the current\r\n *                       test being run.\r\n *\r\n * The member functions are:\r\n *\r\n *   int run()           Start a test run testing until\r\n *                       the end of the file, one test\r\n *                       per line.\r\n *   void process()      Process and run an individual\r\n *                       test.\r\n *\r\n * Author:  Douglas Wilhelm Harder\r\n * COpyright (c) 2006-9 by Douglas Wilhelm Harder.  All rights reserved.\r\n *\r\n * DO NOT EDIT THIS FILE\r\n *************************************************/\r\n\r\n#ifndef TESTER_H\r\n#define TESTER_H\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n\r\n#include \"ece250.h\"\r\n\r\ntemplate <class ClassName>\r\nclass Tester {\r\n    protected:\r\n\t\tClassName *object;\r\n\t\tstd::string command;\r\n\r\n\tpublic:\r\n\t\tTester( ClassName *obj = 0 ):object( obj ) {\r\n\t\t\t// emtpy constructor\r\n\t\t}\r\n\r\n\t\tint run();\r\n\t\tvirtual void process() = 0;\r\n};\r\n\r\n/****************************************************\r\n * int run()\r\n *\r\n * Indefinite run of test cases: continue reading console\r\n * input until the end of the file.\r\n ****************************************************/\r\n\r\ntemplate <class ClassName>\r\nint Tester<ClassName>::run() {\r\n\t// read the flag which indicates the command to be test and\r\n\t// stop if we have reached the end of the file\r\n\r\n\tece250::allocation_table.stop_recording();\r\n\r\n\tconst static std::string prompt = \" % \";\r\n\r\n\tint ptr = 3;\r\n\r\n\twhile ( true ) {\r\n\t\t// terminate if there is an end-of-file or the user types 'exit'\r\n\r\n\t\tif ( std::cin.eof() ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t++ece250::count;\r\n\t\tstd::cout << ece250::count << prompt;\r\n\r\n\t\tstd::cin >> command;\r\n\r\n\t\t// Remove any comments\r\n\t\tif ( command.substr( 0, 2 ) == \"//\" ) {\r\n\t\t\tchar comment[1024];\r\n\t\t\tstd::cin.getline( comment, 1024 );\r\n\r\n\t\t\tstd::cout << command << comment << std::endl;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// terminate if there is an end-of-file or the user types 'exit'\r\n\r\n\t\tif ( std::cin.eof() ) {\r\n\t\t\tstd::cout << \"Exiting...\" << std::endl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// If the user enters !!,\r\n\t\t//    set the command to be the last command\r\n\t\t// If the user enters !n where n is a number,  (1 <= n < count)\r\n\t\t//    set the command ot be the nth command\r\n\r\n\t\tif ( command == \"!!\" ) {\r\n\t\t\tif ( ece250::count == 1 ) {\r\n\t\t\t\tstd::cout << \"Event not found\" << std::endl;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tcommand = ece250::history[ece250::count - 1];\r\n\t\t} else if ( command[0] == '!' ) {\r\n\t\t\tint n;\r\n\t\t\tstd::istringstream number( command.substr( 1, command.length() - 1 ) );\r\n\t\t\tnumber >> n;\r\n\r\n\t\t\tif ( n <= 0 || n > n || n > 100 ) {\r\n\t\t\t\tstd::cout << \"Event not found\" << std::endl;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tcommand = ece250::history[n];\r\n\t\t}\r\n\r\n\t\t// only track the last 100 commands\r\n\t\tif ( ece250::count <= 100 ) {\r\n\t\t\tece250::history[ece250::count] = command;\r\n\t\t}\r\n\r\n\t\t// start tracking any memory allocations made\r\n\t\tece250::allocation_table.start_recording();\r\n\r\n\t\t// There are five key commands\r\n\r\n\t\tif ( command == \"exit\" ) {\r\n\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\t\t\tece250::allocation_table.stop_recording();\r\n\t\t\tbreak;\r\n\t\t} else if ( command == \"new\" ) {\r\n\t\t\tobject = new ClassName();\r\n\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\r\n\t\t} else if ( command == \"new:\" ) {\r\n\t\t\tint n;\r\n\t\t\tstd::cin >> n;\r\n\t\t\tobject = new ClassName( n );\r\n\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\r\n\t\t} else if ( command == \"delete\" ) {\r\n\t\t\tdelete object;\r\n\t\t\tobject = 0;\r\n\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\t\t} else if ( command == \"summary\" ) {\r\n\t\t\tece250::allocation_table.summary();\r\n\t\t} else if ( command == \"details\" ) {\r\n\t\t\tece250::allocation_table.details();\r\n\t\t} else if ( command == \"memory\" ) {\r\n\t\t\tint n;\r\n\r\n\t\t\tstd::cin >> n;\r\n\r\n\t\t\tif ( n == ece250::allocation_table.memory_alloc() ) {\r\n\t\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\t\t\t} else {\r\n\t\t\t\tstd::cout << \"Failure in memory allocation: expecting \" << n << \" bytes to be allocated, but \" << ece250::allocation_table.memory_alloc() << \" bytes were allocated\" << std::endl;\r\n\t\t\t}\r\n\t\t} else if ( command == \"memory_store\" ) {\r\n\t\t\tece250::allocation_table.memory_store();\r\n\t\t\tstd::cout << \"Okay\" << std::endl;\r\n\t\t} else if ( command == \"memory_change\" ) {\r\n\t\t\tint n;\r\n\r\n\t\t\tstd::cin >> n;\r\n\r\n\t\t\tece250::allocation_table.memory_change( n );\r\n\t\t} else {\r\n\t\t\tprocess();\r\n\t\t}\r\n\r\n\t\t// stop tracking any memory allocations made\r\n\t\tece250::allocation_table.stop_recording();\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n#endif"]],"start1":0,"start2":0,"length1":119,"length2":5117}]],"length":5117,"saved":false}
