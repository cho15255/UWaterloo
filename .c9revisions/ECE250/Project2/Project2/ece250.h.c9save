{"ts":1360849334342,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#ifndef ECE250\r\n#define ECE250\r\n\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <string>\r\n#include <cmath>\r\n#include \"Exception.h\"\r\n\r\n/****************************************************************************\r\n * **************************************************************************\r\n * * You don't have to use the Tester classes to use this to manage your\r\n * * memory.  All you must do is include this file and then, if you ever\r\n * * want to test if you have memory which is currently unallocated,\r\n * * you may use ece250::allocation_table.summary();\r\n * *\r\n * * You must simply indicate that you want to start recording by\r\n * * using ece250::alocation_table.summary();\r\n * *\r\n * **************************************************************************\r\n ****************************************************************************/\r\n\r\n/****************************************************************************\r\n * ece250\r\n * Author:  Douglas Wilhelm Harder\r\n * Copyright (c) 2006-9 by Douglas Wilhelm Harder.  All rights reserved.\r\n *\r\n * DO NOT EDIT THIS FILE\r\n *\r\n * This file is broken into two parts:\r\n *\r\n *   1. The first namespace ece250 is associated with tools used by the\r\n *      second part.\r\n *   2. The second has globally overloaded new, delete, new[], and delete[].\r\n *\r\n * This tracks everything that deals with memory allocation (new and new[])\r\n * and memory deallocation (delete and delete[]).\r\n *\r\n * Each time 'new' or 'new[]' is called, an appropriate entry is\r\n * set in a hash table 'allocation_table'.  The hash function of any address\r\n * is the last log[2](array_size) bits.\r\n *\r\n * Each time that 'delete' or 'delete[]' is called, it is checked whether:\r\n *   1. the memory was actually allocated,\r\n *   2. the appropriate form of delete versus delete[] is being called, and\r\n *   3. delete/delete[] has been called multiple times.\r\n *\r\n * The class also stores how much memory was allocated and how much was\r\n * deallocated.  The summary() function prints a summary indicating the\r\n * difference.  When this is called at the end of a test, the result must\r\n * be zero (0).\r\n *\r\n * If there is a problem with either allocation or deallocation, two events\r\n * occur:  a warning is printed and an exception is thrown.\r\n *\r\n * Each throw is associated with a warning sent to the student through cout.\r\n ****************************************************************************/\r\n\r\nnamespace ece250 {\r\n    int memory_alloc_store;\r\n\r\n\tconst size_t PAD = 16;\r\n\r\n\tclass overflow {};\r\n\tclass invalid_deletion {};\r\n\r\n\t// Each time a student calls either new or new[], the\r\n\t// information about the memory allocation is stored in\r\n\t// an instance of this class\r\n\r\n\tclass Allocation {\r\n\t\tpublic:\r\n\t\t\tvoid *address;\r\n\t\t\tsize_t size;\r\n\t\t\tbool is_array;\r\n\t\t\tbool deleted;\r\n\r\n\t\t\tAllocation():\r\n\t\t\taddress( 0 ),\r\n\t\t\tsize( 0 ),\r\n\t\t\tis_array( false ),\r\n\t\t\tdeleted( false ) {\r\n\t\t\t\t// Empty constructor\r\n\t\t\t}\r\n\r\n\t\t\tAllocation( void *a, size_t s, bool i ):\r\n\t\t\taddress( a ),\r\n\t\t\tsize( s ),\r\n\t\t\tis_array( i ),\r\n\t\t\tdeleted( false ) {\r\n\t\t\t\t// Empty constructor\r\n\t\t\t}\r\n\t};\r\n\r\n\tint to_int( int *ptr ) {\r\n\t\tint result = *ptr;\r\n\r\n\t\tif ( result < 0 ) {\r\n\t\t\tresult = result + (1 << (sizeof( int ) - 1));\r\n\t\t}\r\n\r\n\t\treturn result >> 3;\r\n\t}\r\n\r\n\t// All instances of an allocation are stored in this chained hash table\r\n\r\n\tclass HashTable {\r\n\t\tprivate:\r\n\t\t\tint array_size;\r\n\t\t\tAllocation *allocated;\r\n\t\t\tint total_memory_alloc;\r\n\t\t\tint total_memory_deleted;\r\n\t\t\tbool record;\r\n\r\n\t\tpublic:\r\n\t\t\t// Initialize all of the addresses to 0\r\n\r\n\t\t\tHashTable( int as ):\r\n\t\t\tarray_size( as ),\r\n\t\t\ttotal_memory_alloc( 0 ),\r\n\t\t\ttotal_memory_deleted( 0 ),\r\n\t\t\trecord( false ) {\r\n\t\t\t\tallocated = new Allocation[array_size];\r\n\t\t\t}\r\n\r\n\t\t\tint reserve( int N ) {\r\n\t\t\t\t// N must be a power of 2\r\n\r\n\t\t\t\tif ( (N & ((~N) + 1)) != N ) {\r\n\t\t\t\t\tthrow illegal_argument();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete [] allocated;\r\n\t\t\t\tarray_size = N;\r\n\t\t\t\tallocated = new Allocation[array_size];\r\n\t\t\t}\r\n\r\n\t\t\tint memory_alloc() const {\r\n\t\t\t\treturn total_memory_alloc - total_memory_deleted;\r\n\t\t\t}\r\n\r\n\t\t\tvoid memory_store() const {\r\n\t\t\t\tmemory_alloc_store = total_memory_alloc - total_memory_deleted;\r\n\t\t\t}\r\n\r\n\t\t\tvoid memory_change( int n ) const {\r\n\t\t\t\tint memory_alloc_diff = total_memory_alloc - total_memory_deleted - memory_alloc_store;\r\n\r\n\t\t\t\tif ( memory_alloc_diff != n ) {\r\n\t\t\t\t\tstd::cout << \"WARNING: expecting a change in memory allocation of \" << n << \" bytes, but the change was \" << memory_alloc_diff << std::endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Insert uses the last log[2]( array_size ) bits of the address as the hash function\r\n\t\t\t// It finds an unallocated entry in the array and stores the information\r\n\t\t\t// about the memory allocation in that entry, including:\r\n\t\t\t//      The amount of memory allocated,\r\n\t\t\t//      Whether new or new[] was used for the allocation, and\r\n\t\t\t//      The address of the allocated memory.\r\n\r\n\t\t\tvoid insert( void *ptr, size_t size, bool is_array ) {\r\n\t\t\t\tif ( !record ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the hash function is the last log[2]( array_size ) bits\r\n\t\t\t\tint hash = to_int( reinterpret_cast<int *>( &ptr ) ) & (array_size - 1);\r\n\r\n\t\t\t\tfor ( int i = 0; i < array_size; ++i ) {\r\n\t\t\t\t\t// It may be possible that we are allocated the same memory\r\n\t\t\t\t\t// location twice (if there are numerous allocations and\r\n\t\t\t\t\t// deallocations of memory.  Thus, the second check is necessary,\r\n\t\t\t\t\t// otherwise it may introduce session dependant errors.\r\n\r\n\t\t\t\t\tif ( allocated[hash].address == 0 || allocated[hash].address == ptr ) {\r\n\t\t\t\t\t\t// Store the address, the amount of memory allocated,\r\n\t\t\t\t\t\t// whether or not new[] was used, and set 'deleted' to false.\r\n\r\n\t\t\t\t\t\tallocated[hash] = Allocation( ptr, size, is_array );\r\n\r\n\t\t\t\t\t\t// Add the memory allocated to the total memory allocated.\r\n\t\t\t\t\t\ttotal_memory_alloc += size;\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\thash = (hash + 1) & (array_size - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstd::cout << \"WARNING: allocating more memory than is allowed for this project\" << std::endl;\r\n\t\t\t\tthrow overflow();\r\n\t\t\t}\r\n\r\n\t\t\t// Remove checks:\r\n\t\t\t//     If the given memory location was allocated in the first place, and\r\n\t\t\t//     If the appropriate form of delete was used, i.e., delete versus delete[], and\r\n\t\t\t//     If delete has already been called on this object\r\n\r\n\t\t\tsize_t remove( void *ptr, bool is_array ) {\r\n\t\t\t\tif ( !record || ptr == 0 ) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the hash function is the last log[2]( array_size ) bits\r\n\t\t\t\tint hash = to_int( reinterpret_cast<int *>( &ptr ) ) & ( array_size - 1 );\r\n\r\n\t\t\t\t// Continue searching until we've checked all bins\r\n\t\t\t\t// or we find an empty bin.\r\n\r\n\t\t\t\tfor ( int i = 0; i < array_size && allocated[hash].address != 0; ++i ) {\r\n\t\t\t\t\tif ( allocated[hash].address == ptr ) {\r\n\t\t\t\t\t\t// First check if:\r\n\t\t\t\t\t\t//    1. If the wrong delete was called (e.g., delete[] when new was\r\n                        \t\t\t//       used or delete when new[] was used).\r\n\t\t\t\t\t\t//    2. If the memory has already been deallocated previously.\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// If the deletion is successful, then:\r\n\t\t\t\t\t\t//    1. Set the 'deleted' flag to 'true', and\r\n\t\t\t\t\t\t//    2. Add the memory deallocated ot the total memory deallocated.\r\n\r\n\t\t\t\t\t\tif ( allocated[hash].is_array  != is_array ) {\r\n\t\t\t\t\t\t\tif ( allocated[hash].is_array ) {\r\n\t\t\t\t\t\t\t\tstd::cout << \"WARNING: use 'delete [] ptr;' to use memory allocated with 'ptr = new Class[array_size];'\" << std::endl;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstd::cout << \"WARNING: use 'delete ptr;' to use memory allocated with 'ptr = new Class(...);'\" << std::endl;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tthrow invalid_deletion();\r\n\t\t\t\t\t\t} else if ( allocated[hash].deleted ) {\r\n\t\t\t\t\t\t\tstd::cout << \"WARNING: calling delete twice on the same memory location: \" << ptr << std::endl;\r\n\t\t\t\t\t\t\tthrow invalid_deletion();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tallocated[hash].deleted = true;\r\n\t\t\t\t\t\ttotal_memory_deleted += allocated[hash].size;\r\n\r\n\t\t\t\t\t\t// zero the memory before it is deallocated\r\n\r\n\t\t\t\t\t\tchar *cptr = static_cast<char *>( ptr );\r\n\r\n\t\t\t\t\t\tfor ( size_t j = 0; j < allocated[hash].size; ++j ) {\r\n\t\t\t\t\t\t\tcptr[j] = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn allocated[hash].size;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\thash = (hash + 1) & (array_size - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If we've gotten this far, this means that the address was\r\n\t\t\t\t// never allocated, and therefore we are calling delete on\r\n\t\t\t\t// something which should be deleted.\r\n\r\n\t\t\t\tstd::cout << \"WARNING: deleting a pointer to which memory was never allocated: \" << ptr << std::endl;\r\n\t\t\t\tthrow invalid_deletion();\r\n\t\t\t}\r\n\r\n\t\t\t// Print a difference between the memory allocated and the memory deallocated\r\n\r\n\t\t\tvoid summary() {\r\n\t\t\t\tstd::cout << \"Memory allocated minus memory deallocated: \"\r\n\t\t\t\t     << total_memory_alloc - total_memory_deleted << std::endl;\r\n\t\t\t}\r\n\r\n\t\t\t// Print the difference between total memory allocated and total memory deallocated.\r\n\r\n\t\t\tvoid details() {\r\n\t\t\t\tstd::cout << \"SUMMARY OF MEMORY ALLOCATION:\" << std::endl;\r\n\r\n\t\t\t\tstd::cout << \"  Memory allocated:   \" << total_memory_alloc << std::endl;\r\n\t\t\t\tstd::cout << \"  Memory deallocated: \" << total_memory_deleted << std::endl << std::endl;\r\n\r\n\t\t\t\tstd::cout << \"INDIVIDUAL REPORT OF MEMORY ALLOCATION:\" << std::endl;\r\n\t\t\t\tstd::cout << \"  Address  Using  Deleted  Bytes   \" << std::endl;\r\n\r\n\t\t\t\tfor ( int i = 0; i < array_size; ++i ) {\r\n\t\t\t\t\tif ( allocated[i].address != 0 ) {\r\n\t\t\t\t\t\tstd::cout << \"  \" << allocated[i].address\r\n\t\t\t\t\t\t          << ( allocated[i].is_array ? \"  new[]     \" : \"  new       \" )\r\n\t\t\t\t\t\t          << ( allocated[i].deleted  ? \"Y    \" : \"N    \" )\r\n\t\t\t\t\t\t          << std::setw( 6 )\r\n\t\t\t\t\t\t          << allocated[i].size << std::endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Start recording memory allocations\r\n\r\n\t\t\tvoid start_recording() {\r\n\t\t\t\trecord = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop recording memory allocations\r\n\r\n\t\t\tvoid stop_recording() {\r\n\t\t\t\trecord = false;\r\n\t\t\t}\r\n\r\n\t\t\tbool is_recording() {\r\n\t\t\t\treturn record;\r\n\t\t\t}\r\n\t};\r\n\r\n\tbool asymptotic_tester( double *array, int N, int k, bool ln ) {\r\n\t\tdouble *ratios = new double[N];\r\n\t\tdouble *differences = new double[N- 1];\r\n\r\n\t\tint M = 2;\r\n\r\n\t\tfor ( int i = 0; i < N; ++i ) {\r\n\t\t\tratios[i] = array[i] / (M*(ln ? std::log( static_cast<double>( M ) ) : 1.0));\r\n\r\n\t\t\tM = M*(1 << k);\r\n\r\n\t\t}\r\n\r\n\t\tfor ( int i = 0; i < N - 1; ++i ) {\r\n\t\t\tdifferences[i] = ratios[i + 1] - ratios[i];\r\n\t\t\t// std::cout << differences[i] << std::endl;\r\n\t\t}\r\n\r\n\t\tfor ( int i = 1; i < N - 1; ++i ) {\r\n\t\t\tif ( !( differences[i] < 0 ) ) {\r\n\t\t\t\tif ( differences[i] > differences[i - 1] ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdelete [] ratios;\r\n\t\tdelete [] differences;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tHashTable allocation_table( 8192 );\r\n\r\n\tstd::string history[101];\r\n\tint count = 0;\r\n\r\n\tvoid initialize_array_bounds( char *ptr, size_t size ) {\r\n\t\tfor ( int i = 0; i < PAD; ++i ) {\r\n\t\t\tptr[i] = 63 + i;\r\n\t\t\tptr[size - i - 1] = 89 + i;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid check_array_bounds( char *ptr, size_t size ) {\r\n\t\tfor ( int i = 0; i < PAD; ++i ) {\r\n\t\t\tif ( ptr[i] != 63 + i ) {\r\n\t\t\t\tstd::cout << \"Memory before the array located at adderss \"\r\n\t\t\t\t          << static_cast<void *>( ptr + PAD ) << \" was overwritten\" << std::endl;\r\n\t\t\t\tthrow out_of_bounds();\r\n\t\t\t}\r\n\r\n\t\t\tif ( ptr[size - i - 1] != 89 + i ) {\r\n\t\t\t\tstd::cout << \"Memory after the array located at adderss \"\r\n\t\t\t\t          << static_cast<void *>( ptr + PAD ) << \" was overwritten\" << std::endl;\r\n\r\n\t\t\t\tthrow out_of_bounds();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/****************************************************************************\r\n * new\r\n * Author:  Douglas Wilhelm Harder\r\n * Overloads the global operator new\r\n *\r\n * Use malloc to perform the allocation.\r\n * Insert the pointer returned by malloc into the hash table.\r\n *\r\n * The argument 'false' indicates that this is a call\r\n * to new (versus a call to new[]).\r\n *\r\n * Return the pointer to the user.\r\n ****************************************************************************/\r\n\r\nvoid *operator new( size_t size ) {\r\n\tvoid *ptr = malloc( size );\r\n\tece250::allocation_table.insert( ptr, size, false );\r\n\treturn static_cast<void *>( ptr );\r\n}\r\n\r\n/****************************************************************************\r\n * delete\r\n * Author:  Douglas Wilhelm Harder\r\n * Overloads the global operator delete\r\n *\r\n * Remove the pointer from the hash table (the entry is not truly removed,\r\n * simply marked as removed).\r\n *\r\n * The argument 'false' indicates that this is a call\r\n * to delete (versus a call to delete[]).\r\n *\r\n * Use free to perform the deallocation.\r\n ****************************************************************************/\r\n\r\nvoid operator delete( void *ptr ) {\r\n\tece250::allocation_table.remove( ptr, false );\r\n\tfree( ptr );\r\n}\r\n\r\n/****************************************************************************\r\n * new[]\r\n * Author:  Douglas Wilhelm Harder\r\n * Overloads the global operator new[]\r\n *\r\n * Use malloc to perform the allocation.\r\n * Insert the pointer returned by malloc into the hash table.\r\n *\r\n * The argument 'true' indicates that this is a call\r\n * to new[] (versus a call to new).\r\n *\r\n * Return the pointer to the user.\r\n ****************************************************************************/\r\n\r\nvoid *operator new[]( size_t size ) {\r\n\tchar *ptr = static_cast<char *>( malloc( size + 2*ece250::PAD ) );\r\n\tece250::allocation_table.insert( static_cast<void *>( ptr + ece250::PAD ), size, true );\r\n\tece250::initialize_array_bounds( ptr, size + 2*ece250::PAD );\r\n\treturn static_cast<void *>( ptr + ece250::PAD );\r\n}\r\n\r\n/****************************************************************************\r\n * delete[]\r\n * Author:  Douglas Wilhelm Harder\r\n * Overloads the global operator delete[]\r\n *\r\n * Remove the pointer from the hash table (the entry is not truly removed,\r\n * simply marked as removed).\r\n *\r\n * The argument 'true' indicates that this is a call\r\n * to delete[] (versus a call to delete).\r\n *\r\n * Use free to perform the deallocation.\r\n ****************************************************************************/\r\n\r\nvoid operator delete[]( void *ptr ) {\r\n\tsize_t size = ece250::allocation_table.remove( ptr, true );\r\n\r\n\tif ( ece250::allocation_table.is_recording() ) {\r\n\t\tece250::check_array_bounds( static_cast<char *>( ptr ) - ece250::PAD, size + 2*ece250::PAD );\r\n\t}\r\n\r\n\tfree( static_cast<char *>( ptr ) - ece250::PAD );\r\n}\r\n#endif"]],"start1":0,"start2":0,"length1":0,"length2":14318}]],"length":14318}
