{"ts":1363915907521,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*************************************************\n * Tester<Class_name>\n * The top-level testing class.  Each derived\n * class inherits the routines:\n *\n *    int run()\n *\n * For a derived class to function, it must\n * override the void process() member function.\n * The process function should read in a line from\n * the input file and tests the routine based on\n * those instructions.\n *\n * The member variables are:\n *\n *   Class_name *object   A pointer to the object\n *                       being tested.\n *\n *   string command      The string read in from\n *                       the input file indicating\n *                       the next command to be\n *                       tested.\n *\n *   int count           The number of the current\n *                       test being run.\n *\n * The member functions are:\n *\n *   int run()           Start a test run testing until\n *                       the end of the file, one test\n *                       per line.\n *   void process()      Process and run an individual\n *                       test.\n *\n * Author:  Douglas Wilhelm Harder\n * Copyright (c) 2006-9 by Douglas Wilhelm Harder.  All rights reserved.\n *\n * DO NOT EDIT THIS FILE\n *************************************************/\n\n#ifndef TESTER_H\n#define TESTER_H\n\n#include <iostream>\n#include <string>\n#include <sstream>\n\n#include \"ece250.h\"\n\ntemplate <class Class_name>\nclass Tester {\n\tprotected:\n\t\tClass_name *object;\n\t\tstd::string command;\n\n\tpublic:\n\t\tTester( Class_name *obj = 0 ):\n\t\tobject( obj ) {\n\t\t\t// emtpy constructor\n\t\t}\n\n\t\tint run();\n\t\tvirtual void process() = 0;\n};\n\n/****************************************************\n * int run()\n *\n * Indefinite run of test cases: continue reading console\n * input until the end of the file.\n ****************************************************/\n\ntemplate <class Class_name>\nint Tester<Class_name>::run() {\n\t// read the flag which indicates the command to be test and\n\t// stop if we have reached the end of the file\n\n\tece250::allocation_table.stop_recording();\n\n\tconst static std::string prompt = \" % \";\n\n\tint ptr = 3;\n\n\twhile ( true ) {\n\t\t// terminate if there is an end-of-file or the user types 'exit'\n\n\t\tif ( std::cin.eof() ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t++ece250::count;\n\t\tstd::cout << ece250::count << prompt;\n\n\t\tstd::cin >> command;\n\n\t\t// Remove any comments\n\t\tif ( command.substr( 0, 2 ) == \"//\" ) {\n\t\t\tchar comment[1024];\n\t\t\tstd::cin.getline( comment, 1024 );\n\n\t\t\tstd::cout << command << comment << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// terminate if there is an end-of-file or the user types 'exit'\n\n\t\tif ( std::cin.eof() ) {\n\t\t\tstd::cout << \"Exiting...\" << std::endl;\n\t\t\tbreak;\n\t\t}\n\n\t\t// If the user enters !!,\n\t\t//    set the command to be the last command\n\t\t// If the user enters !n where n is a number,  (1 <= n < count)\n\t\t//    set the command ot be the nth command\n\n\t\tif ( command == \"!!\" ) {\n\t\t\tif ( ece250::count == 1 ) {\n\t\t\t\tstd::cout << \"Event not found\" << std::endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcommand = ece250::history[ece250::count - 1];\n\t\t} else if ( command[0] == '!' ) {\n\t\t\tint n;\n\t\t\tstd::istringstream number( command.substr( 1, command.length() - 1 ) );\n\t\t\tnumber >> n;\n\n\t\t\tif ( n <= 0 || n > n || n > 100 ) {\n\t\t\t\tstd::cout << \"Event not found\" << std::endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcommand = ece250::history[n];\n\t\t}\n\n\t\t// only track the last 100 commands\n\t\tif ( ece250::count <= 100 ) {\n\t\t\tece250::history[ece250::count] = command;\n\t\t}\n\n\t\t// start tracking any memory allocations made\n\t\tece250::allocation_table.start_recording();\n\n\t\t// There are five key commands\n\n\t\tif ( command == \"exit\" ) {\n\t\t\tstd::cout << \"Okay\" << std::endl;\n\t\t\tece250::allocation_table.stop_recording();\n\t\t\tbreak;\n\t\t} else if ( command == \"new\" ) {\n\t\t\tobject = new Class_name();\n\t\t\tstd::cout << \"Okay\" << std::endl;\n\t\n\n\t\t} else if ( command == \"delete\" ) {\n\t\t\tdelete object;\n\t\t\tobject = 0;\n\t\t\tstd::cout << \"Okay\" << std::endl;\n\t\t} else if ( command == \"summary\" ) {\n\t\t\tece250::allocation_table.summary();\n\t\t} else if ( command == \"details\" ) {\n\t\t\tece250::allocation_table.details();\n\t\t} else if ( command == \"memory\" ) {\n\t\t\tint n;\n\n\t\t\tstd::cin >> n;\n\n\t\t\tif ( n == ece250::allocation_table.memory_alloc() ) {\n\t\t\t\tstd::cout << \"Okay\" << std::endl;\n\t\t\t} else {\n\t\t\t\tstd::cout << \"Failure in memory allocation: expecting \" << n << \" bytes to be allocated, but \" << ece250::allocation_table.memory_alloc() << \" bytes were allocated\" << std::endl;\n\t\t\t}\n\t\t} else if ( command == \"memory_store\" ) {\n\t\t\tece250::allocation_table.memory_store();\n\t\t\tstd::cout << \"Okay\" << std::endl;\n\t\t} else if ( command == \"memory_change\" ) {\n\t\t\tint n;\n\n\t\t\tstd::cin >> n;\n\n\t\t\tece250::allocation_table.memory_change( n );\n\t\t} else {\n\t\t\tprocess();\n\t\t}\n\n\t\t// stop tracking any memory allocations made\n\t\tece250::allocation_table.stop_recording();\n\t}\n\n\treturn 0;\n}\n#endif\n"]],"start1":0,"start2":0,"length1":0,"length2":4798}]],"length":4798}
